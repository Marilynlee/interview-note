# JS设计模式及具体应用
目的： 高内聚低耦合，提高代码复用性，减少冗余，提高代码扩展性，维护项目稳定性

## 设计原则
- S单一职责原则Single Responsibility Principle ： 一个程序只做好一件事，如果功能过于复杂就拆分开，每个部分保持独立
- O开放/封闭原则OpenClosed Principle ： 对扩展开放，对修改封闭，增加需求时，扩展新代码，而非修改已有代码
- L里氏替换原则Liskov Substitution Principle ： 子类能覆盖父类 父类能出现的地方子类就能出现
- I接口隔离原则Interface Segregation Principle ： 保持接口的单一独立 类似单一职责原则，这里更关注接口
- D依赖倒转原则Dependency Inversion Principle ： 面向接口编程，依赖于抽象而不依赖于具体实现 使用方只关注接口而不关注具体类的实现

## 设计模式的类型

## 1. 结构型模式（Structural Patterns）
通过识别系统中组件间的简单关系来简化系统的设计。
### 外观模式（Facade Pattern）

简而言之外观设计模式就是把多个子系统中复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的API。
- 优： 减少系统相互依赖。提高灵活性。提高了安全性
- 缺： 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

**_应用场景_**：JQuery就把复杂的原生DOM操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。
Axios 不同环境请求不同的http模块、浏览器兼容问题

```javascript
    let addMyEvent = function (el, ev, fn) {
        if (el.addEventListener) {
            el.addEventListener(ev, fn, false)
        } else if (el.attachEvent) {
            el.attachEvent('on' + ev, fn)
        } else {
            el['on' + ev] = fn
        }
    };
```  
### 代理模式（Proxy Pattern）

当访问一个对象本身的代价太高（比如太占内存、初始化时间太长等）或者需要增加额外的逻辑又不修改对象本身时便可以使用代理。ES6中也增加了 Proxy 的功能。
- 优：将代理对象与被调用对象分离，降低了系统的耦合度。在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用
代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；
- 缺： 处理请求速度可能有差别，非直接访问存在开销

**_应用场景_**：html元素的事件代理、ES6的proxy
```html
<ul id="ul">
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
<script>
  let ul = document.querySelector('#ul');
  ul.addEventListener('click', event => {
    console.log(event.target);
  });
</script>
```

## 2. 创建型模式（Creational Patterns）
处理对象的创建，常规方式可能会导致设计问题，或增加设计的复杂度。创建型模式根据实际情况使用合适的方式创建对象。
### 工厂模式（Factory Pattern）
工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。

分为：
- 简单工厂模式：批量生产相同属性的产品；通过声明的工厂函数接参，返回对象
- 复杂工厂模式：可以根据不同类型创建不同的产品；通过声明的工厂函数，可以根据需求拓展生产不同的产品

**_应用场景_**：要依据不同环境创建不同实例；处理大量具有相同熟悉的小对象

网页端存储Token，根据不同浏览器类型，创建不同对象。   在浏览器支持H5的时候，存储token于localStorage; 在不支持h5的浏览器中还是存于cookie.
- 优： 创建对象的过程可能很复杂，但我们只需要关心创建结果。 构造函数和创建者分离, 符合“开闭原则” 一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
- 缺：添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度

### 单例模式（Singleton Pattern）
特点:在整个程序的运行过程中一个类型只有一个实例对象. 通过指定的构造函数, 无论创建多少次对象, 都只有一个。实现方式： 全局变量、静态属性、闭包惰性函数
- 优：划分命名空间，减少全局变量。增强模块性，把自己的代码组织在一个全局变量名下，便于维护。只会实例化一次。简化了代码的调试和维护
- 缺：由于单例模式是一种单点访问，所以它有可能导致模块间的强耦合，不利于单元测试。

**_应用场景_**：定义命名空间，vuex和redux中的store
```javascript
// 单例构造器
const FooServiceSingleton = (function () {
  // 隐藏的Class的构造函数
  function FooService() {}
  // 未初始化的单例对象
  let fooService;
  return {
    // 创建/获取单例对象的函数
    getInstance: function () {
    if (!fooService) {
      fooService = new FooService();
    }
      return fooService;
    }
  }
})();
```
### 构造函数模式

构造函数用于创建特定类型的对象。不仅声明了使用的对象，构造函数还可以接收参数以便第一次创建对象的时候设置对象的成员值。可以自定义构造函数，然后在里面声明自定义类型对象的属性和方法。

**_应用场景_**：构造函数new对象、class

### 原型模式
创建对象成本较大，而同一个类的不同对象之间差别不大（大部分字段都相同），可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式（重新创建一个对象开销比较大，不合适，通过原型模式，帮你在原有对象克隆或拷贝出）

**_应用场景_**：prototype、Object.create是原型模式的一种实现
```javascript
const obj={
    name:'xiaoming',
    getName(){
        console.log(this.name)
    }
} 
let a=Object.create(obj)
a.name='lili'
a.getName() // lili
```

## 3. 行为型模式（Behavioral Patterns）
用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。
### 观察者模式（发布--订阅模式）
被观察对象（subject）维护一组观察者（observer），当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者。
一个目标者对象 Subject，拥有方法：添加 / 删除 / 通知 Observer；多个观察者对象 Observer拥有方法：接收 Subject 状态变更通知并处理；

**_应用场景_**：vue的mvvm

- 优：目标对象与观察者之间的抽象耦合关系能单独扩展以及重用，增加了灵活性。观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。
- 缺：过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解

**发布订阅模式**：基于一个事件（主题）通道，希望接收通知的对象 Subscriber 通过自定义事件订阅主题，被激活事件的对象 Publisher 通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。

### 策略模式（Strategy Pattern）
策略类：定义一系列的策略，把它们一个个封装成函数，统一封装进一个对象;
环境类：定义一个方法，该方法可根据参数自动选择执行对应的策略。
- 优：利用组合、多态等技术将算法封装在独立的strategy中，使得它们易于切换，扩展，利用委托、组合让Context拥有执行算法的能力，更轻便的代替继承。可以有效的避免多重条件选择语句，提供了对开放-封闭原则的完美支持。
- 缺：会在程序中增加许多策略类或者策略对象，要使用策略模式，必须了解所有的strategy及之间的不同点，这样才能选择一个合适的strategy

**_应用场景_**：表单验证；一个系统需要动态地在几种算法中选择一种；

### 命令模式

降低对象之间的耦合度，新的命令可以很容易地加入到系统中， 调用同一方法实现不同的功能

**_应用场景_**：网页富文本编辑器操作，浏览器封装了一个命令对象

### 模块模式
封装统一的模块

**_应用场景_**：requirejs、commonjs、ES6module

### 模板模式

很多事情的流程步骤都是一模一样, 只是部分细节不同，可以在父类型定义这个模板, 封装这些固定的操作，子类重写部分方法

**_应用场景_**：vue的solt，react的children

## 附图

![设计模式和设计模型](https://pic3.zhimg.com/80/v2-771663eac6fb7b8fd29e21bfb704e5da_720w.jpg)

---------------
[返回主页](https://github.com/Marilynlee/interview-note)
