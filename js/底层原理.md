# ES6面试题

## 1. 执行上下文
   当执行一段js代码时，会生成对应的执行环境（context），又叫执行上下文。执行环境主要分为:
   - 全局执行上下文：基础上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置this的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
   - 函数执行上下文: 每当一个函数被调用时,都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。
   - eval执行上下文: 执行在eval函数内部的代码也会有它属于自己的执行上下文

**执行栈**： 即“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。

ES3执行上下文生命周期： 
 - 创建阶段：
   - 生成变量对象：创建arguments，扫描函数声明，扫描变量声明；
   - 建立作用域链；
   - 确定this的指向
 - 执行阶段：
   - 变量赋值
   - 函数的调用
   - 执行其他代码
 - 销毁阶段： 执行完毕出栈，等待回收被销毁

ES5执行上下文生命周期：
- 创建阶段：
    - 确定this的值，也被称为This Binding
    - 创建词法环境（LexicalEnvironment）：词法环境就是相应代码块内标识符与值的关联关系的体现。由以下两部分组成：
      - 环境记录：记录相应代码块的标识符绑定，对应ES3中的变量对象
      - 对外部词法环境的引用（outer）：用于形成多个词法环境在逻辑上的嵌套结构，以实现可以访问外部词法环境变量的能力。对应ES3中的作用域链
    > 全局环境外部环境引用为null； 函数环境包含了arguments对象,外部环境的引用可以是全局环境，也可以是另一个函数环境
    - 创建变量环境（VariableEnvironment）：也是一个词法环境，组成和词法环境相同。_不同点：变量环境用于记录var声明的绑定和函数声明，词法环境用于记录其他声明的绑定（如let、const、class等）_
- 执行阶段：
    - 变量赋值
    - 函数的调用
    - 执行其他代码
- 销毁阶段： 执行完毕出栈，等待回收被销毁
 
## 2.垃圾回收机制
找到内存空间中的垃圾，回收垃圾，让程序能再次利用这部分空间。
- **引用计数法**：通过标记对象的引用次数判断是否可以回收，当引用计数为0立马被回收释放内存空间
    - 优点:  可即刻回收垃圾,所以最大暂停时间很短。不用去遍历堆里面的所有活动对象和非活动对象
    - 缺点： 计数器需要占很大的位置，最大的劣势是无法解决循环引用，导致无法回收的问题
- **标记清除法**： 标记阶段：把所有活动对象（进入执行环境的变量）做上标记。 清除阶段：把没有标记也就是非活动对象（离开执行环境的变量）销毁
    - 优势： 实现简单，打标记也就是打或者不打两种可能，所以就一位二进制位就可以表示。解决了循环引用问题
    - 缺点： 造成内存碎片化，再分配时遍次数多，如果一直没有找到合适的内存块大小，那么会遍历空闲链表(保存堆中所有空闲地址空间的地址形成的链表）一直遍历到尾端
- **V8使用分代式垃圾回收机制**：
V8的垃圾回收的策略也是建立在代际假说的基础之上。代际假说（The Generational Hypothesis）两个特点：
    - 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问。
    - 不死的对象，会活的更久。
  
根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。V8把堆分为新生代和老生代两个区域，同时设计了两个垃圾回收器：副垃圾回收器（负责新生代区域的垃圾回收）和 主垃圾回收器（负责老生代区域的垃圾回收）

 - 新生代：被划分为两个半区（semispace），分别是from space和to space。存放存活时间较短的对象, 采用*复制整理的方式*实现的垃圾回收。在from space到达存储上限时，会执行一次标记，将未被标记的对象复制到to space，复制完成后from和to空间进行调换
 - 老生代：分为两个区域old pointer space 和 old data space分别用来存放GC后还存活的指针信息和数据信息。存放存活时间较长或常驻内存对象，包含大对象或者新生代中晋升的对象（1.新生代中被清理过的对象；2.to空间使用量超过25%时晋升）。 采用*标记-清除*回收垃圾，再采用*标记-整理*解决内存碎片的问题。

由于JS的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为**全停顿(stop-the-world)**。为了减少垃圾回收带来的停顿时间，V8引擎又引入了**Incremental Marking(增量标记)**。 将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。

### 3. 避免内存泄露
- 尽量少用全局变量
- 手动清除定时器
- 减少使用不必要的闭包
- 清除dom引用
- es6 新增了弱引用WeakMap和WeakSet：弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存。

## 4. let、const和var区别？
 - var: 声明的是全局变量，存在变量提升，可以多次重复声明
 - let：声明的是局部变量，不存在变量提升，不可以多次声明， 存在暂时性死区（未定义前调用报错）
 - const：与let一样，但const声明时必须初始化赋值，且值不可修改（如果内存地址没变，引用类型可以更改）

## 5.模块化 AMD commonjs es6Module
- AMD：用异步方式加载模块，依赖前置、提前执行。传入的依赖模块(数组)，会在一开始就下载并执行。
- CMD：用异步方式加载模块，推崇依赖就近、延迟执行。只有到require时依赖模块才执行。
- commonjs： 同步加载的，只有加载完才能执行后面的操作。模块文件都存在本地磁盘，读取非常快，浏览器端限于网络原因，更适合异步加载
  - 运行时调用，加载的是一个对象，该对象只有在脚本运行完才会生成。无法进行静态优化。性能相对较低
  - 输出的是一个值的拷贝，导出的值就不能再变化
  - 模块可多次加载，但模块的运行只在第一次加载时，运行结果被缓存了，以后再加载，就直接读取缓存结果。
- es6Module：
  - 编译时调用，支持编译时静态分析，不需要的方法就不会加载，性能稍高。便于JS引入宏和类型检验，不能包含运行才知道结果的表达式等
  - ES6模块输出的是值的引用，等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
  - ES6的对外接口只是一种静态定义，在代码静态解析阶段就会生成。被输出模块的内部的改变会影响引用的改变

---------------
[返回主页](https://github.com/Marilynlee/interview-note)
