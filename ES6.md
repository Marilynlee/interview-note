# ES6面试题

## 1. 执行上下文
当执行一段js代码时，会生成对应的执行环境（context），又叫执行上下文。执行环境主要分为:
    - 全局执行上下文：基础上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置this的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
    - 函数执行上下文: 每当一个函数被调用时,都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。
    - eval执行上下文: 执行在eval函数内部的代码也会有它属于自己的执行上下文

**执行栈**： 即“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。

ES3执行上下文生命周期： 
 - 创建阶段：
   - 生成变量对象：创建arguments，扫描函数声明，扫描变量声明；
   - 建立作用域链；
   - 确定this的指向
 - 执行阶段：
   - 变量赋值
   - 函数的引用
   - 执行其他代码
 - 销毁阶段： 执行完毕出栈，等待回收被销毁

ES5执行上下文生命周期：
- 创建阶段：
    - 确定this的值，也被称为This Binding
    - 创建词法环境：词法环境就是相应代码块内标识符与值的关联关系的体现。由以下两部分组成：
      - 环境记录：记录相应代码块的标识符绑定，对应ES3中的变量对象
      - 对外部词法环境的引用（outer）：用于形成多个词法环境在逻辑上的嵌套结构，以实现可以访问外部词法环境变量的能力。对应ES3中的作用域链
    > 全局环境外部环境引用为null； 函数环境包含了arguments对象,外部环境的引用可以是全局环境， 也可以是另一个函数环境
    - 创建变量环境：也是一个词法环境，因此它的组成和词法环境相同。不同点在于词法环境（LexicalEnvironment）用于记录其他声明的绑定（如let、const、class等）； 变量环境（VariableEnvironment）用于记录var声明的绑定和函数声明。
- 执行阶段：
    - 变量赋值
    - 函数的引用
    - 执行其他代码
- 销毁阶段： 执行完毕出栈，等待回收被销毁
 
## 2.垃圾回收机制
找到内存空间中的垃圾，回收垃圾，让程序能再次利用这部分空间。
- **引用计数法**：通过标记对象的引用次数判断是否可以回收，当引用计数为0立马被回收释放内存空间
    - 优点:  可即刻回收垃圾,所以最大暂停时间很短。不用去遍历堆里面的所有活动对象和非活动对象
    - 缺点： 计数器需要占很大的位置，最大的劣势是无法解决循环引用无法回收的问题
- **标记清除法**： 标记阶段：把所有活动对象（进入执行环境的变量）做上标记。 清除阶段：把没有标记也就是非活动对象（离开执行环境的变量）销毁
    - 优势： 实现简单，打标记也就是打或者不打两种可能，所以就一位二进制位就可以表示。解决了循环引用问题
    - 缺点： 造成内存碎片化，再分配时遍次数多，如果一直没有找到合适的内存块大小，那么会遍历空闲链表(保存堆中所有空闲地址空间的地址形成的链表）一直遍历到尾端
- **V8使用分代式垃圾回收机制**： 根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。分为新生代和老生代两块

## 3. let、const和var区别？
 - var: 声明的是全局变量，存在变量提升，可以多次重复声明
 - let：声明的是局部变量，不存在变量提升，不可以多次声明，存在暂时性死区（未定以前调用报错）
 - const：与let一样，但const声明时必须初始化赋值，且值不可修改（如果内存地址没变，引用类型可以更改）
