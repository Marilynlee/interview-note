# 性能优化
## 构建优化
 - 开启gzip（compression-webpack-plugin）
 - 静态资源使用CDN，减少打包体积，也可以按需加载
 - 预渲染： 在打包阶段解析js动态渲染页面的工作，采用webpack的prerender-spa-plugin 插件可生成静态结构的html
   路由模式必须为history，否则生成的每个index.html文件的内容都一样
 - webpack-bundle-analyzer包分析工具
 - tree shaking清除我们项目中的一些无用代码，webpack4.x 中默认对tree-shaking进行了支持
 - split chunks设置了异步加载的页面或者组件被打包成独立的bundle，按需加载。webpack 4 默认支持
 - 图片开启压缩，小于10k的图片开启base64格式，减少请求

## 网络资源优化
 - http缓存：分为**强缓存（也称本地缓存）**和**协商缓存（也称304缓存）**
   普通刷新会启用协商缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用 强缓存。

> 强缓存（200）:本地缓存分为：memory cache内存缓存（读取快、持续时间短、容量小）、disk cache硬盘缓存（读取慢、持续时间长、容量大），是最快速的一种缓存方式，只要资源还在缓存有效期内，浏览器就会直接在本地读取，不会请求服务端。

> 协商缓存（304）:是经过浏览器与服务器之间协商过之后，在决定是否读取本地缓存，如果服务器通知浏览器可以读取本地缓存，会返回304状态码，并且协商过程很简单，只会发送头信息，不会发送响应体。
> 缓存优先级: Memory Cache -> Disk Cache -> Push Cache

 - 图片压缩：使用图床工具压缩后上传到CDN
 - 雪碧图，小图片合并为一张大的图片减少http并发，减少请求次数
 - webp格式图片：体积只有只有 JPEG 的2/3，将图片资源大量换成 webp 格式可以加快请求的速度；兼容上还有一定的问题
 - 图片懒加载： 图片很多的时候，全部预设一张默认图，等到滚动到可视区在加载真正的src地址   
 
 - cookie存储的信息尽可能少一些【原因：每一次向服务器发请求，都会把cookie带上】

 - 资源预加载：对当前页面需要的资源，使用 preload 进行预加载，对其它页面需要的资源进行 prefetch 预加载。
 - 异步无阻塞加载JS： `<script src="d.js" defer/async></script>`
     - defer：不阻止解析document，并行下载js；即使下载完js仍继续解析document；按照页面中出现的顺序，在其他同步脚本执行后，DOMContentLoaded 事件前 依次执行js。
    - async：不阻止解析document, 并行下载 b.js；当脚本下载完后立即执行。（执行阶段不确定，可能在DOMContentLoaded事件前或者后）

## 其他优化
 - CSS样式表置于头部，CSS会一边加载一边渲染， JS脚本置于尾部，JS在未加载完成之前，会阻塞渲染
 - CSS优化：避免使用css的@import， 避免使用通配符， 避免使用!impotant， 可以使用transform开启图形加速， 用translate取代left避免页面重排， 选择器嵌套尽量不要超过三层， 提取公共CSS, 避免使用css表达式
 - js优化：
   1. 函数的防抖和节流，降低触发频率
   2. 使用事件委托取代大量事件的绑定
   3. 若需要对DOM进行大量操作，可以使用Fragment减少操作次数
   4. 及时清除没用的定时器


# 其他问题
## 1. 什么是 CRP,即关键渲染路径(Critical Rendering Path)? 如何优化 ?
关键渲染路径是浏览器将 HTML CSS JavaScript 转换为在屏幕上呈现的像素内容所经历的一系列步骤。也就是我们上面说的浏览器渲染流程。
为尽快完成首次渲染,我们需要最大限度减小以下三种可变因素:
- 关键资源的数量: 可能阻止网页首次渲染的资源。
- 关键路径长度: 获取所有关键资源所需的往返次数或总时间。
- 关键字节: 实现网页首次渲染所需的总字节数,等同于所有关键资源传送文件大小的总和。

## 2. 浏览器的回流与重绘
回流必将引起重绘,重绘不一定会引起回流
- **回流(Reflow)**: 当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时,浏览器重新渲染部分或全部文档的过程
> 导致回流的操作： 页面首次渲染, 浏览器窗口大小发生改变, 元素尺寸或位置发生改变元素内容变化（文字数量或图片大小等等）, 元素字体大小变化, 添加或者删除可见的 DOM 元素, 激活 CSS 伪类（例如：:hover）, 查询某些属性或调用某些方法
- **重绘(Repaint)**: 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等）,浏览器会将新样式赋予给元素并重新绘制的过程

浏览器会维护一个队列,把所有引起回流和重绘的操作放入队列中,如果队列中的任务数量或者时间间隔达到一个阈值的,浏览器就会将队列清空,进行一次批处理可以把多次回流和重绘变成一次
```text
// 以下属性或方法时,浏览器会立刻清空队列, 导致回流
clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftwidth、heightgetComputedStyle()getBoundingClientRect()
```
## 3.微前端
   微前端（Micro-Frontends）将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。微前端不是单纯的前端框架或者工具，而是一套架构体系。
   - _**拆分和细化**_：当下单页面应用（SPA）是非常流行的项目形态之一，而随着时间的推移以及应用功能的丰富，单页应用变得越来越庞大难以维护，往往是改一处而动全身，由此带来的发版成本也越来越高。微前端的意义就是将这些庞大应用进行拆分，并随之解耦，每个部分可以单独进行维护和部署，提升效率。
   - _**整合历史系统**_：在不少的业务中会存在一些历史项目，它们采用老的框架类似（Backbone.js，jq等）以B端管理系统为主，介于日常运营，这些系统需要结合到新框架中来使用还不能抛弃，而我们没有理由浪费时间和精力重写旧的逻辑。微前端可以将这些系统进行整合，在基本不修改来逻辑的同时来同时兼容新老两套系统并行运行。

---------------
[返回主页](https://github.com/Marilynlee/interview-note)
